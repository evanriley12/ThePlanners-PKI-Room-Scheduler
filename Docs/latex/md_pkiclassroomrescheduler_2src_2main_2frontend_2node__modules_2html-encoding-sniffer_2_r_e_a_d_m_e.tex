\chapter{Determine the Encoding of a HTML Byte Stream}
\hypertarget{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2html-encoding-sniffer_2_r_e_a_d_m_e}{}\label{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2html-encoding-sniffer_2_r_e_a_d_m_e}\index{Determine the Encoding of a HTML Byte Stream@{Determine the Encoding of a HTML Byte Stream}}
\label{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2html-encoding-sniffer_2_r_e_a_d_m_e_autotoc_md13616}%
\Hypertarget{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2html-encoding-sniffer_2_r_e_a_d_m_e_autotoc_md13616}%
 This package implements the HTML Standard\textquotesingle{}s \href{https://html.spec.whatwg.org/multipage/syntax.html\#encoding-sniffing-algorithm}{\texttt{ encoding sniffing algorithm}} in all its glory. The most interesting part of this is how it pre-\/scans the first 1024 bytes in order to search for certain {\ttfamily \texorpdfstring{$<$}{<}meta charset\texorpdfstring{$>$}{>}}-\/related patterns.


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ htmlEncodingSniffer\ =\ require("{}html-\/encoding-\/sniffer"{});}
\DoxyCodeLine{const\ fs\ =\ require("{}fs"{});}
\DoxyCodeLine{}
\DoxyCodeLine{const\ htmlBuffer\ =\ fs.readFileSync("{}./html-\/page.html"{});}
\DoxyCodeLine{const\ sniffedEncoding\ =\ htmlEncodingSniffer(htmlBuffer);}

\end{DoxyCode}


The returned value will be a canonical \href{https://encoding.spec.whatwg.org/\#names-and-labels}{\texttt{ encoding name}} (not a label). You might then combine this with the \href{https://github.com/jsdom/whatwg-encoding}{\texttt{ whatwg-\/encoding}} package to decode the result\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ whatwgEncoding\ =\ require("{}whatwg-\/encoding"{});}
\DoxyCodeLine{const\ htmlString\ =\ whatwgEncoding.decode(htmlBuffer,\ sniffedEncoding);}

\end{DoxyCode}
\hypertarget{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2html-encoding-sniffer_2_r_e_a_d_m_e_autotoc_md13617}{}\doxysection{\texorpdfstring{Options}{Options}}\label{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2html-encoding-sniffer_2_r_e_a_d_m_e_autotoc_md13617}
You can pass two potential options to {\ttfamily html\+Encoding\+Sniffer}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ sniffedEncoding\ =\ htmlEncodingSniffer(htmlBuffer,\ \{}
\DoxyCodeLine{\ \ transportLayerEncodingLabel,}
\DoxyCodeLine{\ \ defaultEncoding}
\DoxyCodeLine{\});}

\end{DoxyCode}


These represent two possible inputs into the \href{https://html.spec.whatwg.org/multipage/syntax.html\#encoding-sniffing-algorithm}{\texttt{ encoding sniffing algorithm}}\+:


\begin{DoxyItemize}
\item {\ttfamily transport\+Layer\+Encoding\+Label} is an encoding label that is obtained from the "{}transport layer"{} (probably a HTTP {\ttfamily Content-\/\+Type} header), which overrides everything but a BOM.
\item {\ttfamily default\+Encoding} is the ultimate fallback encoding used if no valid encoding is supplied by the transport layer, and no encoding is sniffed from the bytes. It defaults to {\ttfamily "{}windows-\/1252"{}}, as recommended by the algorithm\textquotesingle{}s table of suggested defaults for "{}\+All other locales"{} (including the {\ttfamily en} locale).
\end{DoxyItemize}\hypertarget{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2html-encoding-sniffer_2_r_e_a_d_m_e_autotoc_md13618}{}\doxysection{\texorpdfstring{Credits}{Credits}}\label{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2html-encoding-sniffer_2_r_e_a_d_m_e_autotoc_md13618}
This package was originally based on the excellent work of \href{https://github.com/nicolashenry}{\texttt{ @nicolashenry}}, \href{https://github.com/tmpvar/jsdom/blob/16fd85618f2705d181232f6552125872a37164bc/lib/jsdom/living/helpers/encoding.js}{\texttt{ in jsdom}}. It has since been pulled out into this separate package. 