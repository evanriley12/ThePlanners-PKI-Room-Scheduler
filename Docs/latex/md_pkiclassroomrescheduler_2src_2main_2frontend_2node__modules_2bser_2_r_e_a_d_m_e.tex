\chapter{BSER Binary Serialization}
\hypertarget{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2bser_2_r_e_a_d_m_e}{}\label{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2bser_2_r_e_a_d_m_e}\index{BSER Binary Serialization@{BSER Binary Serialization}}
\label{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2bser_2_r_e_a_d_m_e_autotoc_md6415}%
\Hypertarget{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2bser_2_r_e_a_d_m_e_autotoc_md6415}%
 BSER is a binary serialization scheme that can be used as an alternative to JSON. BSER uses a framed encoding that makes it simpler to use to stream a sequence of encoded values.

It is intended to be used for local-\/\+IPC only and strings are represented as binary with no specific encoding; this matches the convention employed by most operating system filename storage.

For more details about the serialization scheme see \href{https://facebook.github.io/watchman/docs/bser.html}{\texttt{ Watchman\textquotesingle{}s docs}}.\hypertarget{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2bser_2_r_e_a_d_m_e_autotoc_md6416}{}\doxysection{\texorpdfstring{API}{API}}\label{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2bser_2_r_e_a_d_m_e_autotoc_md6416}

\begin{DoxyCode}{0}
\DoxyCodeLine{var\ bser\ =\ require('bser');}

\end{DoxyCode}
\hypertarget{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2bser_2_r_e_a_d_m_e_autotoc_md6417}{}\doxysubsection{\texorpdfstring{bser.\+load\+From\+Buffer}{bser.\+load\+From\+Buffer}}\label{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2bser_2_r_e_a_d_m_e_autotoc_md6417}
The is the synchronous decoder; given an input string or buffer, decodes a single value and returns it. Throws an error if the input is invalid.


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ obj\ =\ bser.loadFromBuffer(buf);}

\end{DoxyCode}
\hypertarget{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2bser_2_r_e_a_d_m_e_autotoc_md6418}{}\doxysubsection{\texorpdfstring{bser.\+dump\+To\+Buffer}{bser.\+dump\+To\+Buffer}}\label{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2bser_2_r_e_a_d_m_e_autotoc_md6418}
Synchronously encodes a value as BSER.


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ encoded\ =\ bser.dumpToBuffer(['hello']);}
\DoxyCodeLine{console.log(bser.loadFromBuffer(encoded));\ //\ ['hello']}

\end{DoxyCode}
\hypertarget{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2bser_2_r_e_a_d_m_e_autotoc_md6419}{}\doxysubsection{\texorpdfstring{Bunser\+Buf}{Bunser\+Buf}}\label{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2bser_2_r_e_a_d_m_e_autotoc_md6419}
The asynchronous decoder API is implemented in the Bunser\+Buf object. You may incrementally append data to this object and it will emit the decoded values via its {\ttfamily value} event.


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ bunser\ =\ new\ bser.BunserBuf();}
\DoxyCodeLine{}
\DoxyCodeLine{bunser.on('value',\ function(obj)\ \{}
\DoxyCodeLine{\ \ console.log(obj);}
\DoxyCodeLine{\});}

\end{DoxyCode}


Then in your socket {\ttfamily data} event\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{bunser.append(buf);}

\end{DoxyCode}
\hypertarget{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2bser_2_r_e_a_d_m_e_autotoc_md6420}{}\doxysection{\texorpdfstring{Example}{Example}}\label{md_pkiclassroomrescheduler_2src_2main_2frontend_2node__modules_2bser_2_r_e_a_d_m_e_autotoc_md6420}
Read BSER from socket\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ bunser\ =\ new\ bser.BunserBuf();}
\DoxyCodeLine{}
\DoxyCodeLine{bunser.on('value',\ function(obj)\ \{}
\DoxyCodeLine{\ \ console.log('data\ from\ socket',\ obj);}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{var\ socket\ =\ net.connect('/socket');}
\DoxyCodeLine{}
\DoxyCodeLine{socket.on('data',\ function(buf)\ \{}
\DoxyCodeLine{\ \ bunser.append(buf);}
\DoxyCodeLine{\});}

\end{DoxyCode}


Write BSER to socket\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{socket.write(bser.dumpToBuffer(obj));}

\end{DoxyCode}
 